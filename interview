# 질문 리스트
## CS
* _브라우저 주소창에 www.google.com 을 입력하면 어떤 일이 일어나나요?_
	* 브라우저가 주소창에 입력된 URL 값을 DNS 서버로 전송하여 IP주소를 받아옵니다. 해당 IP 주소로 html과 같은 리소스 파일을 요청합니다. 받아온 리소스 파일을 브라우저가 렌더링하여 사용자에게 보여줍니다.
* _GET과 POST의 차이_
	* GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트할 때 사용한다.
* 객체와 Class의 차이
	* 객체(Object)란 자신 고유의 속성을 가지는 물리적, 추상적인 모든 대상을 일컫는다. 클래스(Class)란 객체들을 소프트웨어 내에서 구현하기 위해 만든 설계도이며 이를 통해 생성된 객체 하나하나를 클래스의 인스턴스(Instance)라 부른다.
* _객체지향 프로그래밍이란?_
	* 객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.
* 객체지향 프로그래밍의 장단점
	* 장점
		*  코드 재사용이 용이 : 남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있다.
		* 유지보수가 쉬움 : 절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수 혹은 메서드로 존재하기 때문에 해당 부분만 수정하면 된다.
		* 대형 프로젝트에 적합 : 클래스 단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러 명, 여러 회사에서 프로젝트를 개발할 때 업무 분담하기 쉽다.
	* 단점
		* 처리 속도가 상대적으로 느림
		* 객체가 많으면 용량이 커질 수 있음
		* 설계시 많은 시간과 노력이 필요
* _프로세스와 스레드에 대해 설명해주세요._
	* 프로세스 : 운영체제로부터 자원을 할당받는 작업의 단위
	* 스레드 : 할당 받은 자원을 이용하는 실행 단위
* _OAuth_
	* 참여자
		* Resource Server : Client 가 제어하고자 하는 자원을 보유한 서버
			* Facebook, Google, Github, Twitter 등등
		* Resource Owner : 자원의 소유자
			* Client가 제공하는 서비스를 통해 로그인하는 실제 유저
		* Client : Resource Server에 접속해서 정보를 가져오고자 하는 클라이언트(웹 어플리케이션)
	* Flow	![](%EC%A7%88%EB%AC%B8%20%EB%A6%AC%EC%8A%A4%ED%8A%B8/image.png)
## JavaScript
* _callback 과 promise의 차이점_
	* 결과 값 사용 방식 : callback을 사용하면 비동기 로직의 결과값을 처리하기 위해서는 callback안에서만 처리를 해야하고, 콜백 밖에서는 비동기에서 온 값을 알 수가 없습니다. 하지만 promise를 사용하면 비동기에에서 온 값이 promise 객체에 저장되기 때문에 코드 작성이 용이해집니다.
	* 가독성 : callback함수가 중첩될수록 가독성이 안좋아집니다.
* _async, await 사용법_
	* function 앞에 async 를 붙여줍니다. promise 객체 앞에 await 를 붙여줍니다.
* _var,let,const의 차이점_
	* var: 중복 선언 가능, 함수 스코프, 호이스팅 시 선언과 초기화가 동시에 이루어짐
	* const/let: 중복 선언 불가능, 블록 스코프, 호이스팅 시 선언만 이루어짐, TDZ가 존재함, const의 경우 재할당 불가능
* _이벤트 버블링, 캡쳐링에 대해 말해주세요_
	* 버블링 : 이벤트가 자식에서 부모로 전파되는 것을 말함. 예) 모달의 외부를 클릭했을 때만 모달을 종료하고 싶은데, 내부를 클릭해도 모달이 종료됨
	* 캡쳐링 : 이벤트가 부모에서 자식으로 전파되는 것을 말함. 예) ???
* _실행 컨텍스트에 대해 설명해주세요_
	* 실행 컨텍스트는 실행 가능한 코드가 실행되기 위해 필요한 환경이다. VO,SC,this로 이루어져 있으며, 스택 형태로 관리된다.
* _클로져에 대해 설명해주세요_
	* 자신이 생성되었을 때의 환경을 기억하는 함수.  클로져 함수를 사용하면 소멸된 상위 콘텍스트의 활성 객체에 접근할 수 있다. 해당 활성 객체는 참조가 사라지기 전까지 소멸하지 않는다.
* _호이스팅에 대해 설명해주세요._
	* 호이스팅(hoisting)이란, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미합니다.
* _프로토타입에 설명해주세요._
	* 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 Prototype(프로토타입)이라 한다.
* _불변성을 유지하려면 어떻게 해야 하나요?_
	* 원시값들은 기본적으로 불변성이 유지되지만, 그렇지 않은 객체의 경우 스프레드 연산자나 내장함수를 사용합니다. immer와 같은 라이브러리를 사용하는 방법도 있습니다.
	
## React
* _Virtual DOM 이 무엇인지 설명해주세요._
	* 실제 DOM을 자바스크립트 객체 형태로 추상화 시킨 것을 말합니다.
* _React를 사용하는 이유_
	* 방대한 커뮤니티
	* 컴포넌트 기반의 개발로 재사용성 높은 코드를 작성하기 용이하다.
	* Virtual DOM을 사용하여 효율적인 렌더링을 가능케 한다.
* _React에서는 JSX 문법이 어떻게 사용되나요?_
	* JSX 문법을 사용하면 빌드타임에 Babel에 의해서 JS문법으로 컴파일됩니다.
* _useMemo와 useCallback에 대해 설명해주세요_
	* useMemo는 값을 메모이제이션 할 때 사용하고 useCallback은 함수를 메모이제이션 할 때 사용합니다.
* _React의 렌더링 성능을 향상시킬 수 있는 방법_
	* useMemo
	* useCallback
	* React.memo
* _Context API에 대해 설명_
	* 전역 상태관리를 위한 React의 내장 API 입니다. 간단한 프로젝트를 진행시 별도의 라이브러리를 사용하지 않아도 되는 장점이 있습니다.
	
## FrontEnd
* _브라우저 렌더링 과정_
	* Parsing : HTML과 CSS를 가져와서 각각 트리를 생성합니다.
	* Style : 생성된 DOM Tree와 CSSOM Tree를 합쳐 Render Tree를 생성합니다.
	* Layout/Reflow : 생성된 Render Tree의 정확한 배치를 계산합니다.
	* Painting : 생성된 Render Tree의 구성요소들을 실제 픽셀로 변환합니다.
	* Composite : 픽셀로 변환된 요소들을 화면에 표시합니다.
* _Webpack, babel, polyfill의 용도_
	* Webpack : 프로젝트에서 사용된 모듈을 하나의 파일로 묶어준다.
	* Babel : 최신 문법의 코드를 구버전의 브라우져에서 동작할 수 있도록 컴파일해준다.
	* Polyfill : 최신 문법의 코드를 구버전의 코드로 변환시킬 때 대응되는 문법이 없을 경우 동작 방식을 수정하거나 새롭게 구현해준다.
* CSR과 SSR의 차이
	* CSR : 뼈대가 되는 html파일과 렌더링에 필요한 js파일을 서버로부터 다운받아 브라우저단에서 실행하고 그 후 결과에 맞게 렌더링이 일어나는 방식. SEO 적용에 불리
	* SSR : 렌더링 준비가 모두 끝난 리소스를 서버로부터 다운받아 브라우저단에  표시하는 방식이다. SEO 적용에 유리
* _Cors란 무엇이고 어떻게 해결하였는지_
	* 안전하지 않은 요청에 대해 신뢰할 만한 요청인지를 검증하기 위해 도입된 정책. 브라우저에서 안전하지 않은 요청이라고 판단 시 Preflight 요청을 먼저 보내 요청의 Origin 헤더와 서버에서 응답받은 Access-Control-Allow-Origin 헤더를 비교하여 Origin 헤더의 값이 Access-Control-Allow-Origin 헤더에 포함되어 있거나 와일드카드를 응답받을 시 신뢰할 만한 요청이라고 판단하여 본 요청을 수행한다. 해결 방법은 서버에서 응답시 헤더에 원하는 출처를 추가해주면 됩니다.
* _웹 표준을 지키면서 개발 하시는지_
	* 네. 지키려고 노력하며 개발하고 있습니다. 예를 들자면 현재 회사에서 처음 입사했을 당시 모든 API가 Get 과 POST로 이루어져 있었는데 Restful API 도입을 건의하여 받아들여진 경험이 있습니다.
* _이벤트 루프와 태스크 큐_
	* 태스크 큐에는 비동기 함수의 콜백함수, 이벤트 핸들러, 프로미스의 후속처리 함수 등이 저장되고 이벤트 루프는 태스크 큐를 지속적으로 체크하여 실행 컨텍스트로 push 하는 역할을 합니다.
* _타입스크립트를 사용하는 이유_
	* 정적 타입을 사용함으로써 생산성을 높이고 예기치 못한 버그를 방지하기 위함입니다.
* _쿠키, 세션, 로컬스토리지의 차이점_
	* 쿠키는 브라우저에 저장됩니다. 모든 HTTP요청 시 포함되어 전송됨
	* 세션은 서버에 저장됩니다. 브라우저에서는 세션에 접근하기 위한 키를 저장합니다.
	* 로컬스토리지는 브라우저에 저장되지만 삭제하지 않는 한 영구적으로 저장된다. http 요청시에 전송되지도 않으며 용량이 쿠키보다 큼
	

## HTML, CSS
* _cascading에 관해서 설명해주세요_
	* ‘위에서 아래로 흐르는’ 이라는 뜻으로 스타일이 적용되는 우선순위에 대한 원리를 의미합니다.
		* 1순위 : 사용자 스타일 시트(시스템에 저장된 스타일)
		* 2순위 : 제작자가 !important 를 붙인 스타일
		* 3순위 : 제작자가 만든 일반 스타일
		* 4순위 : 기본 브라우저 스타일
* _CSS애니메이션과 JS애니메이션의 차이_
	* JS애니메이션
		* CSS 애니메이션에 비해 호환성이 좋다.
		* 세부적인 이벤트에 대한 애니메이션을 구현할 수 있다.
	* CSS 애니메이션
		* CSS 안에서 모두 구현되기 때문에 관리에 용이하다.

#일상/메모
